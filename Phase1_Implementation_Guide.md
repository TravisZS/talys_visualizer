# Phase 1 实施指南 - 基础架构开发

## 概述
Phase 1的目标是建立TALYS Visualizer的基础架构，包括项目结构、TALYS接口、参数系统和基础GUI框架。

## 项目目录结构

```
talys_visualizer/
├── README.md
├── requirements.txt
├── setup.py
├── main.py                     # 程序入口
├── config/
│   ├── __init__.py
│   ├── settings.py             # 配置文件
│   └── talys_parameters.json   # TALYS参数数据库
├── src/
│   ├── __init__.py
│   ├── core/
│   │   ├── __init__.py
│   │   ├── talys_interface.py  # TALYS接口
│   │   ├── parameter_manager.py # 参数管理
│   │   ├── file_parser.py      # 文件解析
│   │   └── calculation_manager.py # 计算管理
│   ├── gui/
│   │   ├── __init__.py
│   │   ├── main_window.py      # 主窗口
│   │   ├── parameter_panels.py # 参数面板
│   │   ├── plot_widgets.py     # 绘图组件
│   │   └── dialogs.py          # 对话框
│   ├── visualization/
│   │   ├── __init__.py
│   │   ├── base_plot.py        # 基础绘图类
│   │   ├── cross_section.py    # 截面图
│   │   ├── spectra.py          # 能谱图
│   │   └── angular.py          # 角分布图
│   └── utils/
│       ├── __init__.py
│       ├── file_utils.py       # 文件工具
│       ├── data_utils.py       # 数据工具
│       └── logger.py           # 日志系统
├── tests/
│   ├── __init__.py
│   ├── test_talys_interface.py
│   ├── test_parameter_manager.py
│   └── test_file_parser.py
├── build/
│   ├── build_windows.py        # Windows编译脚本
│   ├── build_linux.py          # Linux编译脚本
│   ├── build_macos.py          # macOS编译脚本
│   └── build_all.py            # 自动化构建
├── installer/
│   ├── windows/
│   │   ├── installer.nsi       # NSIS安装脚本
│   │   └── setup.iss           # Inno Setup脚本
│   ├── linux/
│   │   └── create_appimage.sh  # AppImage创建脚本
│   └── macos/
│       └── create_dmg.sh       # DMG创建脚本
├── docs/
│   ├── user_guide.md
│   ├── developer_guide.md
│   ├── build_guide.md          # 编译打包指南
│   └── api_reference.md
└── resources/
    ├── icons/
    ├── templates/
    ├── examples/
    └── talys_binaries/           # 不同平台的TALYS可执行文件
        ├── windows/talys.exe
        ├── linux/talys
        └── macos/talys
```

## Week 1-2: 项目初始化

### 任务清单

#### 1. 环境设置 ✅
```bash
# 创建conda虚拟环境
conda create -n talys_visualizer python=3.11 -y
conda activate talys_visualizer

# 安装依赖
conda install -c conda-forge pyqt matplotlib numpy pandas scipy -y
pip install pyqtgraph nuitka
```

#### 2. requirements.txt ✅
```txt
PyQt6>=6.4.0
matplotlib>=3.6.0
numpy>=1.21.0
pandas>=1.5.0
scipy>=1.9.0
pyqtgraph>=0.13.0
nuitka>=1.8.0
```

#### 3. 基础配置文件 ✅
```python
# config/settings.py
import os
from pathlib import Path

class Settings:
    # 应用信息
    APP_NAME = "TALYS Visualizer"
    APP_VERSION = "0.1.0"
    
    # 路径设置
    BASE_DIR = Path(__file__).parent.parent
    CONFIG_DIR = BASE_DIR / "config"
    RESOURCES_DIR = BASE_DIR / "resources"
    TEMP_DIR = BASE_DIR / "temp"
    
    # TALYS设置
    TALYS_EXECUTABLE = "talys"  # 可在GUI中配置
    TALYS_TIMEOUT = 300  # 5分钟超时
    
    # GUI设置
    WINDOW_WIDTH = 1400
    WINDOW_HEIGHT = 900
    
    # 日志设置
    LOG_LEVEL = "INFO"
    LOG_FILE = BASE_DIR / "logs" / "talys_visualizer.log"
```

#### 4. 主程序入口 ✅
```python
# main.py
import sys
import logging
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import Qt

from src.gui.main_window import MainWindow
from src.utils.logger import setup_logger
from config.settings import Settings

def main():
    # 设置日志
    setup_logger()
    logger = logging.getLogger(__name__)
    
    # 创建应用
    app = QApplication(sys.argv)
    app.setApplicationName(Settings.APP_NAME)
    app.setApplicationVersion(Settings.APP_VERSION)
    
    # 设置应用样式
    app.setStyle('Fusion')
    
    try:
        # 创建主窗口
        main_window = MainWindow()
        main_window.show()
        
        logger.info(f"{Settings.APP_NAME} started successfully")
        
        # 运行应用
        sys.exit(app.exec())
        
    except Exception as e:
        logger.error(f"Application failed to start: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

## Week 3-4: TALYS接口开发

### 核心接口类
```python
# src/core/talys_interface.py
import subprocess
import tempfile
import os
import logging
from pathlib import Path
from typing import Dict, Any, Optional

from config.settings import Settings

class TalysInterface:
    """TALYS计算接口"""
    
    def __init__(self, executable_path: str = None):
        self.logger = logging.getLogger(__name__)
        self.executable = executable_path or Settings.TALYS_EXECUTABLE
        self.temp_dir = None
        
    def create_temp_directory(self) -> Path:
        """创建临时工作目录"""
        self.temp_dir = Path(tempfile.mkdtemp(prefix="talys_"))
        self.logger.info(f"Created temporary directory: {self.temp_dir}")
        return self.temp_dir
    
    def generate_input_file(self, parameters: Dict[str, Any]) -> Path:
        """生成TALYS输入文件"""
        if not self.temp_dir:
            self.create_temp_directory()
            
        input_file = self.temp_dir / "talys.inp"
        
        with open(input_file, 'w') as f:
            f.write("# Generated by TALYS Visualizer\n")
            f.write(f"# Timestamp: {datetime.now()}\n\n")
            
            # 必需参数
            f.write("# Required parameters\n")
            f.write(f"projectile {parameters['projectile']}\n")
            f.write(f"element {parameters['element']}\n")
            f.write(f"mass {parameters['mass']}\n")
            f.write(f"energy {parameters['energy']}\n\n")
            
            # 可选参数
            f.write("# Optional parameters\n")
            for key, value in parameters.items():
                if key not in ['projectile', 'element', 'mass', 'energy']:
                    f.write(f"{key} {value}\n")
        
        self.logger.info(f"Generated input file: {input_file}")
        return input_file
    
    def run_calculation(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """运行TALYS计算"""
        try:
            # 生成输入文件
            input_file = self.generate_input_file(parameters)
            
            # 切换到工作目录
            original_dir = os.getcwd()
            os.chdir(self.temp_dir)
            
            # 运行TALYS
            self.logger.info("Starting TALYS calculation...")
            result = subprocess.run(
                [self.executable],
                input=open(input_file).read(),
                text=True,
                capture_output=True,
                timeout=Settings.TALYS_TIMEOUT
            )
            
            if result.returncode != 0:
                raise TalysCalculationError(
                    f"TALYS calculation failed: {result.stderr}"
                )
            
            # 解析输出文件
            output_data = self.parse_output_files()
            
            self.logger.info("TALYS calculation completed successfully")
            return output_data
            
        except subprocess.TimeoutExpired:
            raise TalysCalculationError("TALYS calculation timed out")
        except Exception as e:
            self.logger.error(f"TALYS calculation error: {e}")
            raise
        finally:
            os.chdir(original_dir)
    
    def parse_output_files(self) -> Dict[str, Any]:
        """解析TALYS输出文件"""
        output_data = {}
        
        # 解析总截面文件
        total_file = self.temp_dir / "total.tot"
        if total_file.exists():
            output_data['total_cross_section'] = self.parse_cross_section_file(total_file)
        
        # 解析其他输出文件...
        
        return output_data
    
    def parse_cross_section_file(self, file_path: Path) -> Dict[str, list]:
        """解析截面文件"""
        energies = []
        cross_sections = []
        
        with open(file_path, 'r') as f:
            lines = f.readlines()
            
        # 跳过头部注释
        data_start = 0
        for i, line in enumerate(lines):
            if not line.strip().startswith('#'):
                data_start = i
                break
        
        # 解析数据
        for line in lines[data_start:]:
            if line.strip():
                parts = line.split()
                if len(parts) >= 2:
                    try:
                        energy = float(parts[0])
                        xs = float(parts[1])
                        energies.append(energy)
                        cross_sections.append(xs)
                    except ValueError:
                        continue
        
        return {
            'energy': energies,
            'cross_section': cross_sections
        }

class TalysCalculationError(Exception):
    """TALYS计算错误"""
    pass
```

### 参数管理器
```python
# src/core/parameter_manager.py
import json
import logging
from typing import Dict, Any, List, Optional
from pathlib import Path

from config.settings import Settings

class ParameterManager:
    """TALYS参数管理器"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.parameters = {}
        self.load_parameter_database()
    
    def load_parameter_database(self):
        """加载参数数据库"""
        db_file = Settings.CONFIG_DIR / "talys_parameters.json"
        
        if db_file.exists():
            with open(db_file, 'r') as f:
                self.parameters = json.load(f)
        else:
            self.logger.warning("Parameter database not found, using defaults")
            self.create_default_database()
    
    def create_default_database(self):
        """创建默认参数数据库"""
        self.parameters = {
            'required': {
                'projectile': {
                    'type': 'choice',
                    'default': 'n',
                    'choices': ['n', 'p', 'd', 't', 'h', 'a', 'g'],
                    'description': 'Type of incident particle'
                },
                'element': {
                    'type': 'string',
                    'default': 'H',
                    'description': 'Target element symbol'
                },
                'mass': {
                    'type': 'int',
                    'default': 1,
                    'range': [1, 300],
                    'description': 'Target mass number'
                },
                'energy': {
                    'type': 'float',
                    'default': 1.0,
                    'range': [0.001, 200.0],
                    'description': 'Incident energy in MeV'
                }
            },
            'models': {
                'ldmodel': {
                    'type': 'choice',
                    'default': 1,
                    'choices': [1, 2, 3, 4, 5, 6],
                    'description': 'Level density model'
                },
                'strength': {
                    'type': 'choice', 
                    'default': 9,
                    'choices': list(range(1, 11)),
                    'description': 'E1 gamma-ray strength function model'
                }
            }
        }
    
    def get_default_value(self, parameter_name: str) -> Any:
        """获取参数默认值"""
        for group in self.parameters.values():
            if parameter_name in group:
                return group[parameter_name]['default']
        return None
    
    def validate_parameter(self, name: str, value: Any) -> bool:
        """验证参数值"""
        param_info = self.get_parameter_info(name)
        if not param_info:
            return False
            
        param_type = param_info['type']
        
        if param_type == 'choice':
            return value in param_info['choices']
        elif param_type == 'int':
            if 'range' in param_info:
                min_val, max_val = param_info['range']
                return min_val <= value <= max_val
        elif param_type == 'float':
            if 'range' in param_info:
                min_val, max_val = param_info['range']
                return min_val <= value <= max_val
                
        return True
    
    def get_parameter_info(self, name: str) -> Optional[Dict]:
        """获取参数信息"""
        for group in self.parameters.values():
            if name in group:
                return group[name]
        return None
```

## Week 5-6: 基础GUI框架

### 主窗口实现
```python
# src/gui/main_window.py
import logging
from PyQt6.QtWidgets import *
from PyQt6.QtCore import *
from PyQt6.QtGui import *

from config.settings import Settings
from .parameter_panels import BasicParameterPanel
from .plot_widgets import PlotArea

class MainWindow(QMainWindow):
    """主窗口"""
    
    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger(__name__)
        self.init_ui()
        
    def init_ui(self):
        """初始化用户界面"""
        self.setWindowTitle(Settings.APP_NAME)
        self.setGeometry(100, 100, Settings.WINDOW_WIDTH, Settings.WINDOW_HEIGHT)
        
        # 创建中央部件
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # 创建主布局
        main_layout = QHBoxLayout(central_widget)
        
        # 左侧参数面板
        self.parameter_panel = BasicParameterPanel()
        main_layout.addWidget(self.parameter_panel, 1)
        
        # 右侧绘图区域
        self.plot_area = PlotArea()
        main_layout.addWidget(self.plot_area, 3)
        
        # 创建菜单栏
        self.create_menu_bar()
        
        # 创建状态栏
        self.create_status_bar()
        
        # 连接信号
        self.connect_signals()
    
    def create_menu_bar(self):
        """创建菜单栏"""
        menubar = self.menuBar()
        
        # 文件菜单
        file_menu = menubar.addMenu('File')
        
        new_action = QAction('New', self)
        new_action.setShortcut('Ctrl+N')
        file_menu.addAction(new_action)
        
        open_action = QAction('Open', self)
        open_action.setShortcut('Ctrl+O')
        file_menu.addAction(open_action)
        
        save_action = QAction('Save', self)
        save_action.setShortcut('Ctrl+S')
        file_menu.addAction(save_action)
        
        file_menu.addSeparator()
        
        exit_action = QAction('Exit', self)
        exit_action.setShortcut('Ctrl+Q')
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
    
    def create_status_bar(self):
        """创建状态栏"""
        self.status_bar = self.statusBar()
        self.status_bar.showMessage('Ready')
        
        # 添加进度条
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        self.status_bar.addPermanentWidget(self.progress_bar)
    
    def connect_signals(self):
        """连接信号"""
        self.parameter_panel.calculation_requested.connect(
            self.on_calculation_requested
        )
    
    def on_calculation_requested(self, parameters):
        """处理计算请求"""
        self.logger.info("Calculation requested")
        self.status_bar.showMessage("Running TALYS calculation...")
        self.progress_bar.setVisible(True)
        
        # TODO: 启动计算线程
```

## 测试计划

### 单元测试
```python
# tests/test_talys_interface.py
import unittest
import tempfile
from pathlib import Path

from src.core.talys_interface import TalysInterface

class TestTalysInterface(unittest.TestCase):
    
    def setUp(self):
        self.interface = TalysInterface()
        
    def test_create_temp_directory(self):
        temp_dir = self.interface.create_temp_directory()
        self.assertTrue(temp_dir.exists())
        self.assertTrue(temp_dir.is_dir())
    
    def test_generate_input_file(self):
        parameters = {
            'projectile': 'n',
            'element': 'H',
            'mass': 1,
            'energy': 1.0
        }
        
        input_file = self.interface.generate_input_file(parameters)
        self.assertTrue(input_file.exists())
        
        # 检查文件内容
        content = input_file.read_text()
        self.assertIn('projectile n', content)
        self.assertIn('element H', content)

if __name__ == '__main__':
    unittest.main()
```

## 里程碑检查

### Week 6 检查点
- [x] 项目结构完整
- [x] TALYS接口基本功能（测试通过）
- [ ] 参数管理系统
- [x] 基础GUI框架
- [x] 单元测试通过
- [x] 能够运行简单的TALYS计算

## 设计决策更新

### 输出文件处理策略
**设计原则**: 简单实用，避免过度复杂化

**通用文件查看器**:
- 显示所有TALYS输出文件列表
- 点击文件名查看文本内容
- 支持搜索和过滤功能

**重点文件可视化**:
- `total.tot` - 总截面图表
- `*.spe` - 能谱图表
- `*.ang` - 角分布图表
- `channels.out` - 反应道信息表格

**其他文件**:
- 纯文本查看
- 导出和打印功能
- 后续可扩展更多可视化类型
